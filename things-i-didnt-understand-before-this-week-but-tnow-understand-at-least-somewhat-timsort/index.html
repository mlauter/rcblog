<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>Things I didn't understand before this week but now understand (at least somewhat) : Timsort &#8211; Miriam at Hacker School</title>
<meta name="description" content="My first venture into the python source code">
<meta name="keywords" content="TIDUBTWBNU/AS, python, cpython, source code, sorting">
<!-- Twitter Cards -->
	
		<meta name="twitter:card" content="summary">
		<meta name="twitter:image" content=
			
				
						"https://mlauter.github.io/images/"
				
			
		>
	
	<meta name="twitter:title" content="Things I didn't understand before this week but now understand (at least somewhat) : Timsort">
	<meta name="twitter:description" content="My first venture into the python source code">
	<meta name="twitter:creator" content="@miriamlauter">


<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="Things I didn't understand before this week but now understand (at least somewhat) : Timsort">
<meta property="og:description" content="My first venture into the python source code">
<meta property="og:url" content="https://mlauter.github.io/things-i-didnt-understand-before-this-week-but-tnow-understand-at-least-somewhat-timsort/">
<meta property="og:site_name" content="Miriam at Hacker School">





<link rel="canonical" href="https://mlauter.github.io/things-i-didnt-understand-before-this-week-but-tnow-understand-at-least-somewhat-timsort/">
<link href="https://mlauter.github.io/feed.xml" type="application/atom+xml" rel="alternate" title="Miriam at Hacker School Feed">


<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Google Webfonts -->
<link href='http://fonts.googleapis.com/css?family=PT+Sans+Narrow:400,700|PT+Serif:400,700,400italic' rel='stylesheet' type='text/css'>
<!-- For all browsers -->
<link rel="stylesheet" href="https://mlauter.github.io/assets/css/main.min.css">

<meta http-equiv="cleartype" content="on">

<!-- HTML5 Shiv and Media Query Support -->
<!--[if lt IE 9]>
	<script src="https://mlauter.github.io/assets/js/vendor/html5shiv.min.js"></script>
	<script src="https://mlauter.github.io/assets/js/vendor/respond.min.js"></script>
<![endif]-->

<!-- Modernizr -->
<script src="https://mlauter.github.io/assets/js/vendor/modernizr-2.7.1.custom.min.js"></script>

<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="https://mlauter.github.io/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="https://mlauter.github.io/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="https://mlauter.github.io/images/apple-touch-icon-precomposed.png">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="https://mlauter.github.io/images/apple-touch-icon-72x72-precomposed.png">
<!-- 114x114 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="https://mlauter.github.io/images/apple-touch-icon-114x114-precomposed.png">
<!-- 144x144 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://mlauter.github.io/images/apple-touch-icon-144x144-precomposed.png">

</head>

<body class="post">

<!--[if lt IE 9]><div class="browser-upgrade alert alert-info">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> to improve your experience.</div><![endif]-->

<div class="navigation-wrapper">
	<div class="site-name">
		<a href="https://mlauter.github.io">Miriam at Hacker School</a>
	</div><!-- /.site-name -->
	<div class="top-navigation">
		<nav role="navigation" id="site-nav" class="nav">
		    <ul>
		        
				<li><a href="https://mlauter.github.io/posts/" >Posts</a></li>
		        
				<li><a href="https://mlauter.github.io/about/" >About</a></li>
		        
		    </ul>
		</nav>
	</div><!-- /.top-navigation -->
</div><!-- /.navigation-wrapper -->



<div id="main" role="main">
  <div class="article-author-side">
    
	<img src="https://mlauter.github.io/images/miriam_bio-photo.jpg" class="bio-photo" alt="Miriam Lauter bio photo"></a>

<h3>Miriam Lauter</h3>
<p>I'm a person learning stuff.</p>
<a href="http://github.com/mlauter" class="author-social" target="_blank"><i class="fa fa-github"></i> Github</a>
<a href="http://twitter.com/miriamlauter" class="author-social" target="_blank"><i class="fa fa-twitter-square"></i> Twitter</a>


<a href="http://linkedin.com/in/miriamlauter" class="author-social" target="_blank"><i class="fa fa-linkedin-square"></i> LinkedIn</a>








  </div>
  <article>
    <div class="headline-wrap">
      
        <h1><a href="https://mlauter.github.io/things-i-didnt-understand-before-this-week-but-tnow-understand-at-least-somewhat-timsort/" rel="bookmark" title="Things I didn't understand before this week but now understand (at least somewhat) : Timsort">Things I didn't understand before this week but now understand (at least somewhat) : Timsort</a></h1>
      
    </div><!--/ .headline-wrap -->
    <div class="article-wrap">
      <table class="image">
<caption align="bottom">timsort: from sortvis.org/algorithms/timsort.html</caption>
<tr><td><img src="http://sortvis.org/images/dense-timsort.png" alt="timsort: from sortvis.org/algorithms/timsort.html" /></td></tr>
</table>

<p>This morning I was curious about how the built-in <code>sorted()</code> function works in python. So with the help of Tom, one of the facilitators here at Hacker School, I took my first dive into the python source code.</p>

<p><br />
If you’ve heard anything about Timsort, what you probably know is that it takes advantage of partial ordering in the array you’re trying to sort in order to improve performance. Basically, instead of having a one-size-fits-all algorithm, Timsort chooses different approaches based on some stuff about the array it’s given.This is good because real world data is usually not totally random, that is, it usually does have some order or “sortedness” to it already. </p>

<p><br />
What I wanted to know, though, was how does this actually work?</p>

<p><br />
I don’t know any C, but handily, within the CPython source code, there is a text file written by Tim Peters, explaining his eponymous function. Here is what I learned.</p>

<h3 id="if-the-array-that-you-are-trying-to-sort-has-fewer-than-64-elements-timsort-will-simply-do-a-binary-insertion-sort">1. If the array that you are trying to sort has fewer than 64 elements, Timsort will simply do a <strong>binary insertion sort</strong>.</h3>

<p>In a normal insertion sort, you would start with the first element of the array and check it against the next item over. If the first item is greater than the second, you flip them, otherwise, you leave them where they are. Now you know your first two items are sorted, so you move on to the third item. You then figure out where the third item belongs by checking from right to left. If item 3 is larger than the preceeding item, you can leave it where it is. Otherwise, you need to check the first item. You continue on down the array until you’ve placed each item in its proper location.</p>

<iframe width="560" height="315" src="//www.youtube.com/embed/ROalU379l3U" frameborder="0" allowfullscreen=""> </iframe>

<p>In the <em>binary</em> version, instead of searching through the elements one by one, you perform a binary search to find the appropriate location. This means, you go to the midway point of the array you’re searching through, and decide whether your item is greater or smaller. Once you pick a half, then you choose the midpoint of that half and check again. Repeat until you are checking an array of length 2, and you find your spot. Though this method doesn’t improve the running time O(n2) of insertion sort, it turns out that comparing two things is much more costly (at least in python?) than swapping, so it improves performance.</p>

<h3 id="the-notion-of-runs">2. The notion of “<strong>runs</strong>”</h3>

<p>The <strong>run</strong> is a very important concept for Timsort. If you have an array longer    than 64 elements, the algorithm will take a first pass through the array checking    for chunks that are stricty increasing or strictly decreasing (if the chunk is    decreasing, it will be reversed). </p>

<p>If these chunks are longer than a certain size, known as minrun, which is    determined based on the size of the array,<sup id="fnref:1"><a href="#fn:1" class="   footnote">1</a></sup> then this is a <strong>natural run</strong>–it occured naturally in your    array. If the chunk is shorter than minrun, you grab <code>minrun - len(chunk)</code> items    ahead of your chunk, and perform a <strong>binary insertion sort</strong> to create an    artificial run. </p>

<p>After this, what you have is an array of sorted chunks of varying lengths. If your    data was totally random, then chunks will probably all be close to the minrun    length. If not, you could have natural runs of wildly varying lengths:</p>

<p><img src="../images/timsort_list_image.jpg" alt="An array with consecutive, descending runs, a, b, and c" /></p>

<h3 id="merging">3. Merging</h3>

<p>The next step is to merge sort your sorted chunks. We are only allowed to merge adjacent chunks so that items do not get out of order with respect to the intervening chunks. One important property of Timsort is that it is <em>stable</em>,    meaning that items of equal value remain sorted in order with respect to their original positions in the list. (I’ll come back to this later).</p>

<p>As Timsort finds runs, it adds them to a stack (so an item seen first in the array goes on first and is at the bottom of the stack).</p>

<p><img src="../images/timsort_stack_image.jpg" alt="the stack of runs" /></p>

<p>Timsort tries to balance two competing needs when merging runs. On the one hand,    we want to put off merging chunks in case it turns out merging our current run    with the next run would be better than (more efficient than) merging with the    previous run. On the other hand, we don’t want to let the stack get too big,    because then we’ll have to reach really far down to get those earlier items, which    would hinder performance. To enforce a compromise, Timsort keeps track of the    three most recent items on the stack and creates two laws that must hold true of    those items:</p>

<blockquote>
  <blockquote>
    <ol>
      <li>a &gt; b+c</li>
      <li>b &gt; c </li>
    </ol>
  </blockquote>
</blockquote>

<p>If either of these laws are broken when a new run is pushed to the stack, items    are merged. If a is larger than c, a and b are merged, otherwise b and c are merged   .</p>

<h3 id="timruns-merge-sort">4. Timrun’s merge sort</h3>

<p>Normal merge sort (recall that our runs are already sorted within, so you can skip    to 3:25 in the video):</p>

<iframe width="560" height="315" src="//www.youtube.com/embed/XaqR3G_NVoo" frameborder="0" allowfullscreen=""></iframe>

<p>Usually, merging adjacent runs of different lengths <em>in place</em> (remember that    stable thing) is very hard. In order to get around this, Timsort sets aside some    temporary memory, and places the smaller of the two runs (let’s call them a and b)    into that temporary space. </p>

<p><img src="../images/Timsort_tempmerge_image.jpg" alt="temporary memory" /></p>

<p>Or, imagine the line of ladies in white from the video move their line over to    stage left in front of the men. They perform the same operation (or dance)    checking the first item in a (women) against b(men), and the victor fills in the    spaces that a has vacated. (If b is smaller the merge sort has to be performed    backwards, but I won’t go into that.)</p>

<p>Actually, what Timsort does is slightly more complicated than this, which brings    me to the last point:</p>

<h3 id="galloping">5. Galloping</h3>

<p><img src="http://upload.wikimedia.org/wikipedia/commons/d/dd/Muybridge_race_horse_animated.gif" alt="galloping" /></p>

<p>So, Timsort is going along merging a and b, and it notices that one run or the    other has been “winning” many times in a row. For a concrete example, imagine if,    in the dancing video, it turned out that all the women had lower numbers than all    the men. All the women would just end up standing back in their original places,    but after doing a lot of extra work. </p>

<p>Timsort takes advantage of the fact that data often has some preexisting internal    structure, and assumes that if a lot of a’s values are lower than b’s, then it is    likely that a will continue to have smaller values than b. </p>

<p>Timsort then enters “galloping mode.” Instead of checking the first/leftmost    unsorted values of a and b against one another (i.e. going through one at a time),    Timsort performs a binary search for the appropriate position of b[0] in a[0].    That way, a whole slice of a can be moved back into place. Then it searches for    the appropriate location of a[0] in b, and a whole section of b can be moved at    once. </p>

<p>It turns out, this operation is not worth it if the appropriate location for b[0]    is very close to the beginning of a (or vice versa), so gallop mode quickly exits    if it isn’t paying off. Additionally, Timsort takes note, and makes it harder to    enter gallop mode later by increasing the number of consecutive a-only or b-only    wins required to enter. If gallop mode <em>is</em> paying off, Timsort makes it easier to    reenter. </p>

<p><br />
And there you have it, Timsort.</p>

<p>An interesting note: Though Timsort’s great performance on arrays with some preexisting internal sorting is its best-known feature, it seems like having a stable sort was one of the main motivators behind adopting timsort. Previously, in order to achieve a stable sort, you’d have to zip the items in your list up with integers, and sort it as an array of tuples. How irritating.</p>

<p>P.S. I know I’ve glossed over some complexity here, but that aside, if you’re reading this and think I’ve totally misunderstood or mis-explained something, just head on over to my github, and shoot me an email to let me know.</p>

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>Minrun is a value between or including 32 to 64 such that len(array) equals or is slightly less than a power of 2. We'll see why this is important later on, but the idea is when you do a merge sort, you want to have a power of two number of things to sort. 
      	</p>
    </li>
  </ol>
</div>


      <hr />
      <footer role="contentinfo">
        <div class="article-author-bottom">
          
	<img src="https://mlauter.github.io/images/miriam_bio-photo.jpg" class="bio-photo" alt="Miriam Lauter bio photo"></a>

<h3>Miriam Lauter</h3>
<p>I'm a person learning stuff.</p>
<a href="http://github.com/mlauter" class="author-social" target="_blank"><i class="fa fa-github"></i> Github</a>
<a href="http://twitter.com/miriamlauter" class="author-social" target="_blank"><i class="fa fa-twitter-square"></i> Twitter</a>


<a href="http://linkedin.com/in/miriamlauter" class="author-social" target="_blank"><i class="fa fa-linkedin-square"></i> LinkedIn</a>








        </div>
        <p class="byline"><strong>Things I didn't understand before this week but now understand (at least somewhat) : Timsort</strong> was published on <time datetime="2014-07-29T00:00:00-04:00">July 29, 2014</time> and last modified on <time datetime="2014-07-31">July 31, 2014</time> by <a href="https://mlauter.github.io/about" title="About Miriam Lauter">Miriam Lauter</a>.</p>
      </footer>
    </div><!-- /.article-wrap -->
  
  </article>
</div><!-- /#main -->

<div class="footer-wrap">
  <div class="related-articles">
  <h4>You might also enjoy <small class="pull-right">(<a href="https://mlauter.github.io/posts/">View all posts</a>)</small></h4>
    <ul>
    
      <li><a href="https://mlauter.github.io/how-to-make-your-own-smart-ac/" title="How to Make Your Own Smart AC">How to Make Your Own Smart AC</a></li>
    
      <li><a href="https://mlauter.github.io/getting-started-with-raspberry-pi/" title="Getting Started With Raspberry Pi">Getting Started With Raspberry Pi</a></li>
    
      <li><a href="https://mlauter.github.io/writing-snake-in-python/" title="Writing Snake in python">Writing Snake in python</a></li>
    
    </ul>
    <hr />
  </div><!-- /.related-articles -->
  <footer>
    <span>&copy; 2014 Miriam Lauter. Powered by <a href="http://jekyllrb.com">Jekyll</a> using the <a href="http://mademistakes.com/minimal-mistakes/">Minimal Mistakes</a> theme.</span>

  </footer>
</div><!-- /.footer-wrap -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="https://mlauter.github.io/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="https://mlauter.github.io/assets/js/scripts.min.js"></script>

	        

</body>
</html>